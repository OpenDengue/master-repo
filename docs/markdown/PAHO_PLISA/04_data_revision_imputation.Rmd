---
title: "04_Data revision and imputation"
output: html_document
---

```{r, echo=FALSE}
knitr::include_graphics("./flowchart/PAHO_process_summary.png")

```


```{r load data, include=FALSE}
data <- read.csv("data/processed_data/PAHO_processed_A.csv")

data %>%
  group_by(adm_0_name)%>% tally()


data <- data %>%
  select(adm_0_name, adm_0_code, year, epidemiological_week, 
         calendar_start_date, calendar_end_date,
         cum_start_date, cum_end_date, cum_interval,
         dengue_total_cumulative, 
         source_id)%>%
  mutate(calendar_start_date = ymd(calendar_start_date), 
         calendar_end_date = ymd(calendar_end_date), 
         cum_start_date = ymd(cum_start_date), 
         cum_end_date = ymd(cum_end_date))

```

## Revisions to cumulative count values

Since some cumulative counts may be revised down over time, we need to identify the rows in our dataset that contain such values. To achieve this, we will use a for loop. For instance, if the cumulative count for week 5 was initially 100 but revised down to 90 in week 6, we will tag week 5 as having revised down values. Cumulative count for week 5 was compared with all subsequent rows (e.g., week 6 to week 53).

```{r revised down, results='hide'}
data$result <- FALSE

#split the dataset by country and year (16 countries * 9 years = 144 datasets) and save them into a list
dt_list <- data %>%
  group_by(adm_0_name, year)%>%
  group_split() 


# iterate over each dataset
for (x in 1:length(dt_list)){
  df <- dt_list[[x]]
  if (nrow(df) < 2) next
  # iterate over each row
  for (i in 1:(nrow(df) - 1)) {
    # if ith row contains NA, skip this row and go to next row
    if (is.na(df$dengue_total_cumulative[i])) next
    
  # iterate over each subsequent row
    for (j in (i + 1):nrow(df)) {
    # skip the row if it's NA and compare with the next row instead
      if (is.na(df$dengue_total_cumulative[j])) next
    
    # compare ith and jth row and if ith row contains value that is larger than a value in jth value, return "TRUE" in "result" column. 
      if (df$dengue_total_cumulative[i] > df$dengue_total_cumulative[j]) {
        dt_list[[x]]$result[i] <- TRUE
        # testing for loop 
        # print(paste0("I compared ", i, "th row and ", j,  " row of dt_list ", x))
    } 
    
  }
}
  # the last row is not compared, so set its value to NA
  #dt_list[[x]]$result[nrow(df)] <-NA
}

view(dt_list[[1]])
# merging datasets back
data2 <- rbindlist(dt_list)
```


```{r revised down result, include=FALSE}
# a list of countries and years with at least one revised cumulative count, and the number of revised counts. 

data2 %>%
  group_by(adm_0_name, year) %>%
  filter(any(result == TRUE)) %>%
  filter(result == TRUE)%>%
  tally()

# we can see that for many countries, cumulative count for the year 2022 has largely been revised down. we might need to update the dataset for 2022 later. 


# cumulative count that has been revised will be replaced with NAs. 
data2 <- data2 %>%
  mutate(dengue_total_cumulative2 = ifelse(result ==TRUE, NA, dengue_total_cumulative))%>%
  mutate(source_id2 = ifelse(result == TRUE, "Revised", source_id))

#source_cat for visualisations
data2 <- data2 %>%
  mutate(source_cat2 = ifelse((grepl("Revised", source_id2) & is.na(dengue_total_cumulative2)), "Revised-NA",
                        ifelse((is.na(source_id2) & is.na(dengue_total_cumulative2)), "NA","Raw")))%>%
  mutate(source_cat = ifelse(source_cat2 %in% c("Revised-NA", "NA"), "NA", source_cat2))

plyr::count(data2$source_cat)
plyr::count(data2$source_cat2)
plyr::count(data2$source_cat)

```

## Zero filling

When the total sum of weekly = annual count (assuming annual count data is correct), NA values were identified and replaced with count values for the following three use cases. 

### Case 1. An entire year without a case  

```{r zero filling-case1, echo=FALSE, results='hide'}
source("function/leveraging_annual_data.R")

cum_dt <- data2 %>%
  mutate(key = paste0(adm_0_name, "_", year))%>%
  mutate(dengue_total_cumulative2 = ifelse(key %in% v1$key, 0, dengue_total_cumulative2))%>%
  mutate(source_cat2 = ifelse(is.na(source_id2)  & dengue_total_cumulative2==0, "Zero1", 
                        ifelse(key %in% v1$key & source_cat %in% c("Raw") & is.na(dengue_total_cumulative2), "Zero1" , paste0(source_cat2))))%>%
  mutate(source_cat = ifelse(source_cat2 %in% c("Zero1"), "Zero", paste0(source_cat)))

summary(data2$dengue_total_cumulative2) # NA=8978
summary(cum_dt$dengue_total_cumulative2) # NA=8679 (decreased from 8978)
plyr::count(cum_dt$source_cat2) # Zero applied to	287 rows

cum_dt_list <- cum_dt %>% 
  group_split(cum_dt$adm_0_name)

cum_p_list <- list()
barcols <- c("Raw" = "#1F77B4", "Zero1" = "#E15759")
dotcols <- c("Raw" = "#1F77B4", "Zero1" = "#E15759")

for (i in 1:length(cum_dt_list)){
  dt <- cum_dt_list[[i]]
cum_p_list[[i]] <- ggplot()+
  geom_bar(data=dt, aes(x=epidemiological_week, y=dengue_total_cumulative2, fill=source_cat2), 
           stat="identity")+
  geom_point(data=subset(dt, dt$dengue_total_cumulative2 ==0), 
             aes(x=epidemiological_week, y=dengue_total_cumulative2, color = source_cat2))+
  ggtitle(paste0(dt$adm_0_name))+
  scale_color_manual(name = "Zeros", values = dotcols)+
  scale_fill_manual(name = "Source", values = barcols)+
  scale_y_continuous(limits=function(x){c(0, max(0.1, x))}, 
                     labels=scales::number_format(big.mark = ',', accuracy=0.1))+

  facet_wrap(year~., scales="free_y")

}
cum_p_list[8];  cum_p_list[33]

# Bermuda, Bonaire, Chile, Curacao, Montserrat, Puerto Rico, Saint Kitts
```
```{r Zero1 result}
summary(cum_dt$dengue_total_cumulative2) # NA=8679 (decreased from 8978)

```

### Case 2. Filling in values for the weeks after the latest cumulative count

```{r zero filling-case2, echo=FALSE, results='hide'}
# 2) is the latest data point = last week of the year?
# filling in 0s for the weeks after the latest cumulative count when compare==0 

x <- cum_dt %>%
  mutate(key2 = paste0(adm_0_name, "_", year, "_", epidemiological_week))%>%
  merge(., v2[c("key", "latest_week", "latest_count")], by=c("key"), all.x=T, all.y=F)%>%
  filter(!(epidemiological_week <= latest_week))%>%
  filter(key %in% v2$key & !source_cat %in% c("Raw"))%>%
  arrange(adm_0_name, year, epidemiological_week)%>%
  mutate(dengue_total_cumulative2 = as.numeric(latest_count))%>%
  mutate(source_cat = "Zero")%>%
  mutate(source_cat2 = "Zero2")

plyr::count(x$source_cat)

cum_dt2 <- cum_dt %>%
  mutate(key2 = paste0(adm_0_name, "_", year, "_", epidemiological_week))%>%
  anti_join(x, by = "key2")

cum_dt2 <- bind_rows(x, cum_dt2)

summary(cum_dt2$dengue_total_cumulative2) # NA=7648 (decreased from 8679)

cum_dt_list2 <- cum_dt2 %>%
  group_split(cum_dt2$adm_0_name)

cum_p_list2 <- list()
barcols <- c("Raw" = "#1F77B4", "Zero1" = "#E15759", "Zero2" = "#FD749D")
dotcols <- c("Raw" = "#1F77B4",  "Zero1" = "#E15759", "Zero2" = "#FD749D")
for (i in 1:length(cum_dt_list2)){
  dt <- cum_dt_list2[[i]]
cum_p_list2[[i]] <- ggplot()+
  geom_bar(data=dt, aes(x=epidemiological_week, y=dengue_total_cumulative2, fill=source_cat2), 
           stat="identity")+
  geom_point(data=subset(dt, dt$dengue_total_cumulative2 ==0), 
             aes(x=epidemiological_week, y=dengue_total_cumulative2, color = source_cat2))+
  ggtitle(paste0(dt$adm_0_name))+
  scale_color_manual(name = "Zeros", values = dotcols)+
  scale_fill_manual(name = "Source", values = barcols)+
  scale_y_continuous(limits=function(x){c(0, max(0.1, x))}, 
                     labels=scales::number_format(big.mark = ',', accuracy = 0.1))+

  facet_wrap(year~., scales="free_y")

}

cum_p_list2[1]; 
cum_p_list2[2]; 

cum_p_list2[4]


#cum_p_list2[8]; cum_p_list2[10]; cum_p_list2[14]; cum_p_list2[18]; cum_p_list2[33]; cum_p_list2[38]; cum_p_list2[40]; cum_p_list2[44]

```
```{r Zero2 result}
summary(cum_dt2$dengue_total_cumulative2) # NA=7648 (decreased from 8679)

```

### Case 3. Duplicated cumulative counts where NAs exist in between

```{r zero filling-case3, echo=FALSE, results='hide'}
# Find duplicated cumulative counts where NAs exist in between, and replace NAs with the duplicated count values. 

# create a lookup table for duplicated non-NA cumulative count values.
dup <- cum_dt2 %>%
  group_by(adm_0_name, year)%>%
  mutate(dup = as.numeric(duplicated(dengue_total_cumulative2) | duplicated(dengue_total_cumulative2, fromLast = TRUE)))%>%
  filter(!is.na(dengue_total_cumulative2))%>%  
  filter(dup==1)%>%
  select(adm_0_name, year, epidemiological_week,  dengue_total_cumulative2)

# mark in which epidemiological week the duplicated count starts and ends. For example, if the cum count values for week 10 to 15 are 10, 12, NA, NA, 12, 13, 13, min_week = 11 and max_week = 14. 
dup2 <- dup %>%
  mutate(key = paste0(adm_0_name, "_", year))%>%
  group_by(key, dengue_total_cumulative2)%>%
  summarise(min_week = min(epidemiological_week), 
            max_week = max(epidemiological_week))

# convert wide to long format and complete sequence column and fill in rows. 
dup3 <- dup2 %>%
  gather(., var, epidemiological_week, min_week:max_week)%>%
  arrange(key, epidemiological_week)%>%
  group_by(key, dengue_total_cumulative2)%>%
  complete(epidemiological_week = first(epidemiological_week):max(epidemiological_week)) %>% select(-var)%>%
  rename(dup_count = dengue_total_cumulative2)

# if there are duplicated cumulative counts where any NA values exist in between, those NAs will be replaced with cum count values
cum_dt3 <- cum_dt2 %>%
  mutate(key = paste0(adm_0_name, "_", year))%>%
  merge(., dup3, by=c("key", "epidemiological_week"), all.x=T, all.y=F)%>%
  mutate(dengue_total_cumulative3 = ifelse(is.na(dengue_total_cumulative2) & is.na(dup_count)==FALSE, 
                                           as.numeric(dup_count), dengue_total_cumulative2))%>%
  mutate(source_cat = ifelse(is.na(dengue_total_cumulative2) & is.na(dup_count)==FALSE, "Zero", source_cat))%>%
  mutate(source_cat2 =ifelse(is.na(dengue_total_cumulative2) & is.na(dup_count)==FALSE, "Zero3", source_cat2))

summary(cum_dt3$dengue_total_cumulative3) #NA 7040 (decreased from 7648)

plyr::count(cum_dt3$source_cat2)


cum_dt_list3 <- cum_dt3 %>%
  group_split(cum_dt3$adm_0_name)

cum_p_list3 <- list()
barcols <- c("Raw" = "#1F77B4", "Zero1" = "#E15759", "Zero2" = "#FD749D", "Zero3" = "#F2947E")
dotcols <- c("Raw" = "#1F77B4",  "Zero1" = "#E15759", "Zero2" = "#FD749D", "Zero3" = "#F2947E")
for (i in 1:length(cum_dt_list3)){
  dt <- cum_dt_list3[[i]]
cum_p_list3[[i]] <- ggplot()+
  geom_bar(data=dt, aes(x=epidemiological_week, y=dengue_total_cumulative3, fill=source_cat2), 
           stat="identity")+
  geom_point(data=subset(dt, dt$dengue_total_cumulative3 ==0), 
             aes(x=epidemiological_week, y=dengue_total_cumulative3, color = source_cat2))+
  ggtitle(paste0(dt$adm_0_name))+
  scale_color_manual(name = "Zeros", values = dotcols)+
  scale_fill_manual(name = "Source", values = barcols)+
  scale_y_continuous(limits=function(x){c(0, max(0.1, x))}, 
                     labels=scales::number_format(accuracy = 0.1, big.mark = ','))+

  facet_wrap(year~., scales="free_y")

}

cum_p_list3[1]; 
cum_p_list3[2]; 
cum_p_list3[3] 
#cum_p_list3[4]; 
#cum_p_list3[5]; 
#cum_p_list3[13]

```
```{r Zero3 result}
summary(cum_dt3$dengue_total_cumulative3) #NA 7040 (decreased from 7648)

```

## Imputation
We first attempted using 'na.approx' function of 'zoo' package. Different imputation approaches will be explored later on. 

```{r imputation trial}

#create epidemiological week 0 row to permit imputation for weeks where epidemiological week has no reported cumulative count.
data3 <- cum_dt3 %>%
  as_tibble() %>%
  group_by(adm_0_name) %>% 
  group_modify(~ add_row(.x,year=2014:2022, 
                         epidemiological_week = 0, 
                         dengue_total_cumulative3 = 0 ,.before = 0))%>% 
  arrange(adm_0_name, year, epidemiological_week)

data3 <- data3 %>%
  group_by(adm_0_name, year)%>%
  mutate(dengue_na_approx = as.integer(na.approx(dengue_total_cumulative3, na.rm=FALSE, rule = 2, maxgap=2)))%>%
    mutate(dengue_na_spline = as.integer(na.spline(dengue_total_cumulative3, na.rm=FALSE, maxgap=2, method="hyman")))%>%
  ungroup()

# maxgap=2 argument is used to specify that the function can fill in missing values up to two consecutive positions in the vector. rule=2 argument was used to ensure that the interpolated values are always greater than or equal to the observed values in the vector. 

summary(data3$dengue_total_cumulative3) 
summary(data3$dengue_na_approx)# NA 6823 (decreased from 7040)

```

## Threshold setting for imputation

```{r count the number of consecutive rows}
# Extract the number of consecutive imputed values for each year and each country
consec <- data.frame(unclass(rle(is.na(data3$dengue_total_cumulative3))))
#  The 'lengths' column indicates the number of consecutive rows and the 'values' column indicates whether cumulative counts are NAs (values==TRUE) or not.

# Highlight those year & epidemiological weeks where there are >= 6 imputed values consecutively, so that these can be discarded moving forward (as we have less confidence in imputed values over periods of longer than 6 weeks)
consec <- consec %>%
  mutate(values2 = ifelse(lengths < 6 & values == TRUE, FALSE, values))

consec <- as.data.frame(lapply(consec, rep, consec$lengths))

data3 <- cbind(data3, consec)
```


```{r count the number of consecutive rows results, include=FALSE}
data3 <- data3 %>%
  # for gaps of 6 weeks of more, replace with NAs
  mutate(dengue_na_approx2 = ifelse(values2==TRUE, NA, dengue_na_approx)) %>%
  mutate(dengue_na_spline2 = ifelse(values2==TRUE, NA, dengue_na_spline)) %>%

  filter(!epidemiological_week==0)%>% #remove epidemiological week = 0
  select(adm_0_name, adm_0_code, year, epidemiological_week, 
         calendar_start_date, calendar_end_date,
         cum_start_date, cum_end_date, cum_interval, 
         dengue_total_cumulative, 
         dengue_total_cumulative3, dengue_na_approx2, dengue_na_spline2, 
         result, source_id, source_id2, source_cat, source_cat2)%>%
  mutate(calendar_start_date = ymd(calendar_start_date), 
         calendar_end_date = ymd(calendar_end_date), 
         cum_start_date = ymd(cum_start_date), 
         cum_end_date = ymd(cum_end_date))
#For data gaps of >= 6 weeks, we will need to base the calendar start date on the previous calendar start date for which we have data. This will mean that these periods present incident counts but over a longer time period, according to the size of the gap.


# As of now, we have imputed cumulative count values ("dengue_na_approx2") that have not been missed for longer than six weeks.
summary(data3$dengue_na_approx2)

data3 <- data3 %>%
  mutate(source_id2 = ifelse(source_cat %in% c("NA") & is.na(dengue_na_approx2)==FALSE, "Imputed", source_id2))%>%
  mutate(source_cat2 = ifelse(grepl("Imputed", source_id2),"Imputed", source_cat2))%>%
  mutate(source_cat = ifelse(source_cat2 %in% c("Imputed"), "Imputed", source_cat))

plyr::count(data3$source_cat)

```

Compare the original raw data, revised data, and imputed data. The black dotted line indicates original raw values but were excluded because those were revised down later, the red line indicates the revised & gap filled data (but not yet imputed), and the blue line shows the imputed data. 

```{r all processes result, fig.width = 20, fig.height = 25,  echo = FALSE, results = "hide"}
data3 %>%
  group_by(adm_0_name, year) %>%
  filter(any(result == TRUE)) %>%
ggplot()+
  geom_line(aes(x=epidemiological_week, y=dengue_total_cumulative), color="black", size=1.5, linetype = "dotted")+
  geom_line(aes(x=epidemiological_week, y=dengue_na_approx2), color="blue", size=1.5)+
  geom_line(aes(x=epidemiological_week, y=dengue_total_cumulative3), color="red", size=1.5)+
  xlab("Epidemiological week") + ylab("Cumulative count")+
  theme(axis.text = element_text(size=15), 
        axis.title= element_text(size=18), 
        strip.text = element_text(size=18))+
  facet_wrap(adm_0_name~year, scales="free_y", ncol=4)

```

## Convert cumulative to incident counts

Prepare dataset for converting cumulative to incident counts. This is more straightforward for data where we have consecutive epidemiological weeks, as a lag column can be created and subtracted from the previous weeks count.

```{r convert cumulative to incident, echo=FALSE}
#create incident count column by subtracting the previous weeks cumulative count from the following weeks cumulative count
inc_dt <- data3 %>% 
  arrange(adm_0_name, year, epidemiological_week)%>%
  group_by(adm_0_name, year)%>% 
  mutate(dengue_total_lag = lag(dengue_total_cumulative3, default=0))%>%
  mutate(dengue_total_inc = dengue_total_cumulative3-dengue_total_lag)%>%
  mutate(dengue_na_approx_lag = lag(dengue_na_approx2, default = 0))%>%
  mutate(dengue_na_approx_inc = dengue_na_approx2-dengue_na_approx_lag) %>% 
  mutate(dengue_na_spline_lag = lag(dengue_na_spline2, default = 0)) %>%
  mutate(dengue_na_spline_inc = dengue_na_spline2-dengue_na_spline_lag) %>% ungroup()

inc_dt %>%
  group_by(source_cat, source_cat2)%>%
  tally()
```
Of 24,440 rows, 151 rows have been replaced with NAs following the 'Revised down' stage. In total 2,155 gaps have been filled following the 'Zero filling' and 'Imputation' stage.  

Following is an example of comparing different imputation methods for Panama and Argentina. Na.spline() function gives better imputation results than na.approx() when converted to incidence count. Na.spline() will only be included in our final dataset. 

```{r imputation methods comparison, fig.width = 20, fig.height = 8, echo=FALSE }
source("function/plot_incidence.R")
source("function/plot_cumulative2.R")

inc_dt_list <- inc_dt %>%
  ungroup()%>%
  group_split(adm_0_name)

argentina <- inc_dt_list[[3]] %>% 
  select(year, epidemiological_week, source_cat,
         dengue_total_inc, dengue_na_approx_inc, dengue_na_spline_inc,
         dengue_na_approx2, dengue_na_spline2)%>%
  filter(year %in% c('2017', '2018'))

guatemala <- inc_dt_list[[26]] %>% 
  select(year, epidemiological_week, source_cat,
         dengue_total_inc, dengue_na_approx_inc, dengue_na_spline_inc,
         dengue_na_approx2, dengue_na_spline2)%>%
  filter(year %in% c('2016', '2017'))

panama <- inc_dt_list[[35]] %>% 
  select(year, epidemiological_week, source_cat,
         dengue_total_inc, dengue_na_approx_inc, dengue_na_spline_inc,
         dengue_na_approx2, dengue_na_spline2)%>%
  filter(year %in% c('2015', '2016'))

#plot_cumulative2(panama); plot_cumulative2_spline(panama)

plot_incidence(panama)+ggtitle("Panama (na.approx)");plot_incidence_spline(panama)+ggtitle("Panama (na.spline)")
plot_incidence(guatemala)+ggtitle("Guatemala (na.approx)");plot_incidence_spline(guatemala)+ggtitle("Guatemala (na.spline)")
plot_incidence(argentina)+ggtitle("Argentina (na.approx)"); plot_incidence_spline(argentina)+ggtitle("Argentina (na.spline)")

```


```{r save final data, include=FALSE}

colnames(inc_dt)
inc_dt2 <- inc_dt %>% 
  #mutate(source_cat = ifelse(cum_interval >1, "NA", source_cat))%>%
  select(adm_0_name, adm_0_code, year, epidemiological_week, 
         calendar_start_date, calendar_end_date, 
         dengue_na_spline2, dengue_na_spline_inc, source_id, source_cat)
write.csv(inc_dt2, "data/transformed_data/PAHO_for_visual.csv", row.names=F)


final_dt <- inc_dt %>%
  ungroup()%>% # drop group vars
  filter(!cum_interval >1)%>%
  filter(!is.na(dengue_na_spline_inc))%>%
  rename(dengue_total = dengue_na_spline_inc)%>%
  mutate(source_cat_n = source_cat)%>%
  mutate(source_cat = ifelse(source_cat_n %in% c("Imputed"), "paho_imputed", "paho_adm0"))%>%
  mutate(adm_1_name = NA, adm_1_code = NA, adm_2_name = NA, adm_2_code = NA, UUID = NA)%>%
  select(adm_0_name, adm_0_code, adm_1_name, adm_1_code, adm_2_name, adm_2_code, 
         calendar_start_date, calendar_end_date, 
         dengue_total, UUID, source_id, source_cat)

plyr::count(final_dt$source_cat)
plyr::count(final_dt$adm_0_name) #52 countries

write.csv(final_dt, "data/transformed_data/PAHO_transformed.csv", row.names=F)
```


