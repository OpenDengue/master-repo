---
title: "03_filling_gaps"
output: html_document
---

For countries with high burden and high coverage , but coverage <100% (n = 16), inspect the cumulative counts visually to look for possible methods to convert cumulative to incident counts. 
For these countries, we will provide:  

1. "Raw" incident counts, with increasing temporal resolution to account for the gaps in reporting, but no modelling.  
2. Modelled estimates for the gaps, through either simple "spreading" methods or more complex interpolation, dependent on the size of the data gap.

## Data preparation

```{r data preparation & visualiszation}
data <- read.csv("processed_data/all_dt_A.csv")

priority <- read.csv("processed_data/Priority_country.csv")

# list of high burden & high coverage countries ("Group 1")
g1 <- priority %>% 
  filter(p_group == "Group 1") %>%
  filter(!cum_overall_pct == 100)%>% droplevels()

print(g1$adm_0_name) 

dt_list1 <- data %>%
  filter(adm_0_name %in% g1$adm_0_name)%>%
  group_split(adm_0_name)

#lapply(dt_list1, plot_cumulative) # produce plots for 16 countries

#plot_cumulative(dt_list1[[1]]) # produce plots for specific country
```
Different data years have different coverage even for the same country.  

For now, we first demonstrate data processing for high burden high coverage countries first. This is because data gaps are bigger for the low coverage countries and therefore different approaches might be needed for those countries. This will be updated as needed. 

```{r data preparation}
data <- data %>%
  select(adm_0_name, adm_0_code, year, epidemiological_week, 
         calendar_start_date, calendar_end_date,
         cum_start_date, cum_end_date, cum_interval,
         dengue_total_cumulative, 
         source_id)%>%
  mutate(calendar_start_date = ymd(calendar_start_date), 
         calendar_end_date = ymd(calendar_end_date), 
         cum_start_date = ymd(cum_start_date), 
         cum_end_date = ymd(cum_end_date))

# demonstrate for high burden high coverage countries first
data2 <- data %>%
  filter(adm_0_name %in% g1$adm_0_name)

#create epidemiological week 0 row to permit imputation for weeks where epidemiological week has no reported cumulative count.
data2 <- data2 %>%
  as_tibble() %>%
  group_by(adm_0_name) %>% 
  group_modify(~ add_row(.x,year=2014:2022, 
                         epidemiological_week = 0, 
                         dengue_total_cumulative = 0 ,.before = 0))%>% 
  arrange(adm_0_name, year, epidemiological_week)
```

## Revisions to cumulative count values

Since some cumulative counts may be revised down over time, we need to identify the rows in our dataset that contain such values. To achieve this, we will use a for loop. For instance, if the cumulative count for week 5 was initially 100 but revised down to 90 in week 6, we will tag week 5 as having revised down values. Cumulative count for week 5 was compared with all subsequent rows (e.g., week 6 to week 53).

```{r correction for the values revised down over time}

data2$result <- FALSE

#split the dataset by country and year (16 countries * 9 years = 144 datasets) and save them into a list
dt_list <- data2 %>%
  group_by(adm_0_name, year)%>%
  group_split() 


# iterate over each dataset
for (x in 1:length(dt_list)){
  df <- dt_list[[x]]
  if (nrow(df) < 2) next
  # iterate over each row
  for (i in 1:(nrow(df) - 1)) {
    # if ith row contains NA, skip this row and go to next row
    if (is.na(df$dengue_total_cumulative[i])) next
    
  # iterate over each subsequent row
    for (j in (i + 1):nrow(df)) {
    # skip the row if it's NA and compare with the next row instead
      if (is.na(df$dengue_total_cumulative[j])) next
    
    # compare ith and jth row and if ith row contains value that is larger than a value in jth value, return "TRUE" in "result" column. 
      if (df$dengue_total_cumulative[i] > df$dengue_total_cumulative[j]) {
        dt_list[[x]]$result[i] <- TRUE
        # testing for loop 
        # print(paste0("I compared ", i, "th row and ", j,  " row of dt_list ", x))
    } 
    
  }
}
  # the last row is not compared, so set its value to NA
  #dt_list[[x]]$result[nrow(df)] <-NA
}

# merging datasets back
data3 <- rbindlist(dt_list)  

# a list of countries and years with at least one revised cumulative count, and the number of revised counts. 

data3 %>%
  group_by(adm_0_name, year) %>%
  filter(any(result == TRUE)) %>%
  filter(result == TRUE)%>%
  tally()

# we can see that for many countries, cumulative count for the year 2022 has largely been revised down. we might need to update the dataset for 2022 later. 


# cumulative count that has been revised will be replaced with NAs. 
data3 <- data3 %>%
  mutate(dengue_total_cumulative2 = ifelse(result ==TRUE, NA, dengue_total_cumulative))%>%
  mutate(source_id = ifelse(result == TRUE, "Revised", source_id))
```
## Imputation
We first attempted using 'na.approx' function of 'zoo' package. Different imputation approaches will be explored later on. 

```{r imputation trial}

data3 <- data3 %>%
  group_by(adm_0_name, year)%>%
  mutate(dengue_na_approx = na.approx(dengue_total_cumulative2, na.rm=FALSE, rule = 2, maxgap=2), 
         dengue_na_spline = na.spline(dengue_total_cumulative2, na.rm=FALSE, maxgap=2))%>%
  ungroup()

# maxgap=2 argument is used to specify that the function can fill in missing values up to two consecutive positions in the vector. rule=2 argument was used to ensure that the interpolated values are always greater than or equal to the observed values in the vector. 
```

Compare the original raw data, revised data, and imputed data. The black dotted line indicates original raw values but were excluded because those were revised down later, the red line indicates the revised data (but not yet imputed), and the blue line shows the imputed data. 

```{r, fig.width = 20, fig.height = 15, include=FALSE, results='hide'}
data3 %>%
  group_by(adm_0_name, year) %>%
  filter(any(result == TRUE)) %>%
ggplot()+
  geom_line(aes(x=epidemiological_week, y=dengue_total_cumulative), color="black", size=1.5, linetype = "dotted")+
  geom_line(aes(x=epidemiological_week, y=dengue_na_approx), color="blue", size=1.5)+

  geom_line(aes(x=epidemiological_week, y=dengue_total_cumulative2), color="red", size=1.5)+
  xlab("Epidemiological week") + ylab("Cumulative count")+
  theme(axis.text = element_text(size=15), 
        axis.title= element_text(size=18), 
        strip.text = element_text(size=18))+
  facet_wrap(adm_0_name~year, scales="free_y", ncol=4)

```

## Threshold setting for imputation

```{r count the number of consecutive rows}
# Extract the number of consecutive imputed values for each year and each country

consec <- data.frame(unclass(rle(is.na(data3$dengue_total_cumulative2))))
#  The 'lengths' column indicates the number of consecutive rows and the 'values' column indicates whether cumulative counts are NAs (values==TRUE) or not.

# Highlight those year & epidemiological weeks where there are >= 6 imputed values consecutively, so that these can be discarded moving forward (as we have less confidence in imputed values over periods of longer than 6 weeks)
consec <- consec %>%
  mutate(values2 = ifelse(lengths < 6 & values == TRUE, FALSE, values))

consec <- as.data.frame(lapply(consec, rep, consec$lengths))

data3 <- cbind(data3, consec)

data3 <- data3 %>%
  # for gaps of 6 weeks of more, replace with NAs
  mutate(dengue_na_approx2 = ifelse(values2==TRUE, NA, dengue_na_approx), 
         dengue_na_spline2 = ifelse(values2==TRUE, NA, dengue_na_spline)) %>%
  filter(!epidemiological_week==0)%>% #remove epidemiological week = 0
  select(adm_0_name, adm_0_code, year, epidemiological_week, 
         calendar_start_date, calendar_end_date,
         cum_start_date, cum_end_date, cum_interval,
         dengue_total_cumulative2, dengue_na_approx2, dengue_na_spline2, source_id)%>%
  mutate(calendar_start_date = ymd(calendar_start_date), 
         calendar_end_date = ymd(calendar_end_date), 
         cum_start_date = ymd(cum_start_date), 
         cum_end_date = ymd(cum_end_date))

# As of now, we have imputed cumulative count values ("dengue_total_na_approx2") that have not been missed for longer than six weeks .
```

## Convert cumulative to incident counts

Prepare dataset for converting cumulative to incident counts. This is more straightforward for data where we have consecutive epidemiological weeks, as a lag column can be created and subtracted from the previous weeks count.

```{r convert cumulative to incident}
#For data gaps of >= 6 weeks, we will need to base the calendar start date on the previous calendar start date for which we have data. This will mean that these periods present incident counts but over a longer time period, according to the size of the gap.

#create incident count column by subtracting the previous weeks cumulative count from the following weeks cumulative count
data4 <- data3 %>% 
  arrange(adm_0_name, year, epidemiological_week)%>%
  group_by(adm_0_name, year) %>% 
  mutate(dengue_na_approx_lag = lag(dengue_na_approx2, default = 0), 
         dengue_na_spline_lag = lag(dengue_na_spline2, default = 0)) %>%
  mutate(dengue_na_approx_inc = dengue_na_approx2-dengue_na_approx_lag, 
         dengue_na_spline_inc = dengue_na_spline2-dengue_na_spline_lag)

#add source_id and source_cat (for visualisations)
data4 <- data4 %>%
  mutate(source_id = ifelse(is.na(source_id) &  is.na(dengue_na_approx_inc)==FALSE,  "impute_from_all_PAHO_countries_PAHO_2014_2022", source_id))%>%
  mutate(source_cat2 = ifelse(grepl("impute_from", source_id),"Imputed", 
                        ifelse((grepl("Revised", source_id) & is.na(dengue_na_approx_inc)==FALSE), "Imputed", 
                          ifelse((grepl("Revised", source_id) & is.na(dengue_na_approx_inc)), "Revised-NA",
                           ifelse((is.na(source_id) & is.na(dengue_na_approx_inc)), "NA", "Raw")))))%>%
  mutate(source_cat = ifelse(source_cat2 %in% c("Revised-NA", "NA"), "NA", source_cat2))


plyr::count(data4$source_cat2)

plyr::count(data4$source_cat)

```

## Visualisations

```{r, fig.width = 18, fig.height = 10}

dt_list2 <- data4 %>%
  ungroup()%>%
  filter(adm_0_name %in% g1$adm_0_name)%>%
  group_split(adm_0_name)

source("function/plot_incidence.R")

lapply(dt_list2, plot_incidence) # produce plots for 16 countries
```

```{r imputation methods comparison, fig.width = 18, fig.height = 10 }
source("function/plot_impute_compare.R")
plyr::count(data4$source_cat) #Imputed, NA, Raw
plyr::count(data4$source_cat2)

impute_compare1 <- data4 %>%
  ungroup()%>%
  select(adm_0_name, year, epidemiological_week, dengue_na_approx_inc, source_cat)%>%
  filter(!source_cat %in% c("Imputed"))%>%
  rename(value = dengue_na_approx_inc)

impute_compare2 <- data4 %>%
  select(adm_0_name, year, epidemiological_week, dengue_na_approx_inc, dengue_na_spline_inc, source_cat)%>%
  filter(source_cat %in% c("Imputed"))%>%
  gather(., method, value, dengue_na_approx_inc:dengue_na_spline_inc)%>%
  select(adm_0_name, year, epidemiological_week, value, source_cat, method)

dt_impute <- impute_compare2 %>%
  ungroup()%>%
  group_split(method)

dt_approx <- dt_impute[[1]]
dt_spline <- dt_impute[[2]]

dt_approx <- merge(dt_approx, impute_compare1, by=c("adm_0_name", "year", "epidemiological_week", "value", "source_cat"), all.x=T, all.y=T)
dt_spline <- merge(dt_spline, impute_compare1, by=c("adm_0_name", "year", "epidemiological_week", "value", "source_cat"), all.x=T, all.y=T)

dt_approx1 <- dt_approx %>%
  group_by(adm_0_name, year) %>%
  filter(any(source_cat %in% c("Imputed")))

dt_spline1 <- dt_spline %>%
  group_by(adm_0_name, year) %>%
  filter(any(source_cat %in% c("Imputed")))

dt_approx_list <- dt_approx1 %>%
  ungroup()%>%
  filter(adm_0_name %in% g1$adm_0_name)%>%
  group_split(adm_0_name, year)

dt_spline_list <- dt_spline1 %>%
  ungroup()%>%
  filter(adm_0_name %in% g1$adm_0_name)%>%
  group_split(adm_0_name, year)


p_list <- list()
for (i in 1:length(dt_approx_list)) { 
x1 <- dt_approx_list[[i]]
x2 <- dt_spline_list[[i]]
colors <- c("#1f77b4", "#ff7f0e" )  # define colors for each group
colors2 <- c("#1f77b4", "#59A14F" )  # define colors for each group

p1 <- ggplot(data=dt_approx_list[[i]], aes(x=epidemiological_week, y=value, fill=source_cat))+
    geom_bar(stat="identity") +
    scale_fill_manual(values=colors, 
                     breaks=c("Raw", "Imputed"), 
                     labels=c("Raw", "Imputed (na.approx)")) +
 
  labs(title=paste0(dt_spline_list[[i]]$adm_0_name, " (", dt_approx_list[[i]]$year, ")"))+
  theme(plot.title = element_text(size=25))+
  theme(axis.title = element_text(size=22),
        axis.text = element_text(size=20))+
  theme(legend.title= element_blank(), 
        legend.text = element_text(size=15))+
  theme(strip.text = element_text(size=22))+
  #facet_wrap(year~., scales= "free_y", strip.position = "top")+
    xlab("Epidemiological week")+
    ylab("Dengue incident cases"); p1

p2 <- ggplot(data=dt_spline_list[[i]], aes(x=epidemiological_week, y=value, fill=source_cat))+
  geom_bar(stat="identity") +
  scale_fill_manual(values=colors2, 
                    breaks=c("Raw", "Imputed"), 
                    labels=c("Raw", "Imputed (na.spline)")) +
  
  labs(title=paste0(dt_spline_list[[i]]$adm_0_name, " (", dt_spline_list[[i]]$year, ")"))+
  theme(plot.title = element_text(size=25))+
  theme(axis.title = element_text(size=22),
        axis.text = element_text(size=20))+
  theme(legend.title= element_blank(), 
        legend.text = element_text(size=15))+
  theme(strip.text = element_text(size=22))+
  #facet_wrap(year~., scales= "free_y", strip.position = "top")+
  xlab("Epidemiological week")+
  ylab("Dengue incident cases")

p_list[[i]] <-ggarrange(p1, p2, ncol=1, nrow=2)

}

p_list[[19]]  
```

Let's see how the data coverage has been updated so far. The figure below shows the weekly data coverage (2014-2022) by sources (raw, imputed, revised, not available) and country. Imputation filled in the gap, whereas revision may have created more. NA refers to the case when the original raw data was not available; Revised-NA refers to the case when the original raw data was available but has been replaced with NAs because they were revised down over time. 

```{r, fig.width = 28, fig.height = 10}
ggplot(data4, aes(x=epidemiological_week, y=adm_0_name, fill=as.factor(source_cat2)))+
  geom_tile(color="white", lwd = 0.1)+
  scale_fill_manual(values = c("#1f77b4", "#2ca02c", "#ff7f0e", "#d62728"),
                     breaks = c("Raw", "Imputed", "Revised-NA", "NA"),
                     labels = c("Raw", "Imputed", "Revised-NA", "NA"))+
  scale_x_continuous(expand = c(0,0))+
  scale_y_discrete(limits=rev)+
  ggtitle("Updated data coverage")+
  xlab("Epidemiological week")+ylab("Country")+
  theme(plot.title = element_text(size=28, family = "bold"),
        axis.title = element_text(size=25))+
  theme(axis.text.y = element_text(size=22), 
        axis.text.x = element_blank())+
  theme(axis.ticks = element_blank())+
  theme(panel.spacing = unit(0.1, "lines"), 
        panel.background = element_rect(fill = 'white'), 
        panel.grid.major = element_blank(),
        plot.margin = unit(c(1,1,1,1), "cm"))+
  theme(strip.background = element_blank(), 
        strip.text = element_text(size=22))+
  theme(legend.title = element_blank(),
        legend.text = element_text(size=18, margin = margin(t = 5)))+
  facet_grid(.~year,  scales = "free", space = "free" )
```

So in summary, what changes have been made to the original raw datasets? 
```{r, fig.width = 15, fig.height = 10}

data4 %>%
  group_by(adm_0_name, source_cat2)%>%
  tally()%>%
  mutate(prop = round(prop.table(n)*100, 1))%>%
  ungroup()%>%
  tidyr::complete(adm_0_name, source_cat2)%>%
  group_by(source_cat2)%>%
  summarise(avg_prop = mean(prop, na.rm=T))

# In average across all countries, imputation filled in 9.4% of 470 weeks of data while revision created 5% (23.5 weeks).

data4 %>%
  group_by(adm_0_name, source_cat2)%>%
  tally()%>%
  mutate(prop = round(prop.table(n)*100, 1))%>%
  ungroup()%>%
  tidyr::complete(adm_0_name, source_cat2)%>%
  filter(!source_cat2 == "Raw")%>%
  mutate(source_cat2 = factor(source_cat2, levels=c("Imputed", "Revised-NA", "NA")))%>%
  #for text annotations on tile
  mutate(labels = ifelse(source_cat2 %in% c("Imputed", "Revised-NA"), paste0( sprintf("%.1f", prop), "%"), ""))%>%
  mutate(labels = ifelse(is.na(prop), "", labels))%>%

  ggplot()+
  geom_tile(aes(x=source_cat2, y=adm_0_name, fill=prop), color = "white",  lwd = 1.5, linetype = 1)+
  geom_text(aes(x = source_cat2, y = adm_0_name, label = labels), color = "black", size= 6)+
  scale_x_discrete(position = "top")+
  scale_y_discrete(limits=rev)+
  ggtitle("Updates to data by country")+
  xlab(NULL) + ylab("Country")+
  scale_fill_distiller(palette = "YlGnBu", direction = 1, na.value="#D9D9D9", name="Proportion (%)")+
  theme(axis.text.x.top = element_text(size=22,  margin = margin(b = 0.1, unit = "in")))+
  theme(plot.title = element_text(size=28, family = "bold", vjust = 5, hjust = 0.08),
        axis.title.y = element_text(size=25,  margin = margin(b = 30)), 
        axis.text.y = element_text(size=22, margin = margin(r = 2)), 
        axis.ticks.x = element_blank(),        
        axis.ticks.y = element_blank(), 
        panel.background = element_rect(fill = 'white'), 
        plot.margin = unit(c(1,1,1,1), "cm"),
        axis.line.x = element_blank(), 
        axis.line.y = element_blank(),
        panel.grid.major = element_blank()
  )+
   theme(legend.title = element_text(size=20),
        legend.text = element_text(size=18, vjust=1),
        #legend.text.align = 0, 
        legend.margin = margin(11,11,11,11), 
        legend.background=element_rect(fill="white"),
        legend.key = element_rect(fill="white")
  )

# Guatemala benefited most from our imputations, whereas Paraguy had the most extensive revisions to its original raw datasets.  
```

