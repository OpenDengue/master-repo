---
title: "OpenDengue data coverage"
author: "Joe Clarke & Ahyoung Lim"
date: "Last update on `r format(Sys.Date(), '%B %d, %Y')`"
output: 
    github_document: default
    html_document:
        theme: flatly
        number_sections: true
        toc: true
        toc_float: true
       
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = ".", output_format = "all") })
---

# Background

This document contains the relevant R code and output for producing country specific summaries of :
1. Current case data data coverage in OpenDengue that has been extracted + processed + merged, while all may not yet be available on the rep, some may be in the process of being uplaoded from shared dropbox. 
2. This data prioritises admin level 1 spatial resolution and the highest temporal resolution available. There may be more data to come at higher spatial resolution.
3. This data forms part of the "primary" dataset for each country, which contains : Temporal resolution, spatial resolution, an aggregate of all dengue cases  (varying definitions of dengue and case severity). This does not include disaggregation by age, sex, disease classification, mortality or serotype. This will follow in a release of the "secondary" dataset for each country.

## Objectives 

The purpose of this is twofold:
1. to be able to identify gaps in data coverage such that we can use opportunistic sources to attempt to fill them. 
2. to link to a three updated heat maps showing coverage by time, space and data source. These will be archived to show progress in OpenDengue. 

```{r setup, include=FALSE}
require("knitr"); require("here"); require("pacman")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = here())
pacman::p_load("dplyr", "lubridate",  "tidyr", "tidyverse",  "knitr", "stringi", "zoo", "EpiWeek", "data.table")
```

# Data preprocessing

```{r include = FALSE}
#* This part could be merged into earlier data processing stage
db1 <- read.csv("data/moh_pahosubnational_tycho_merge.csv")
db2 <- read.csv("data/paho_merge.csv")
colnames(db1)

db1 <- db1 %>% 
  select(-X) %>%
  mutate(source_cat = ifelse(source_cat %in% c("paho"), "paho_sub", source_cat))

names(db1)
names(db2)

plyr::count(db2$source_cat)

db2 <- db2 %>% 
  mutate(source_cat = ifelse(source_cat %in% c("paho-adm0"), "paho_adm0", "paho_imputed"))

data <- rbind(db1, db2)
plyr::count(data$source_cat)
rm(db1, db2)

#write.csv(data, "data/master_data.csv", row.names=F)
```
Create columns for categorising each row according to it's spatial resolution & temporal resolution.

Convert all case counts from PAHO portal to weekly. While they are currently cumulative with the calendar_end_date increasing weekly, we will be developing models to spread this data across weekly counts before release. In the portal itself, all denge cases are only listed cumulatively in single week increments, while incident "suspected" cases are listed weekly. 

```{r}
data <- read.csv("data/master_data.csv")
head(data)
plyr::count(data$source_cat)
plyr::count(data$adm_0_name)

data <- data %>%
  mutate(calendar_start_date = ymd(calendar_start_date), 
         calendar_end_date = ymd(calendar_end_date), 
         year = year(calendar_end_date), 
         diff = as.duration(interval(calendar_start_date, calendar_end_date))%/% as.duration(days(1)))%>%
  mutate(spatial_res = ifelse(adm_1_name %in% NA & adm_2_name %in% NA,  0, 
                       ifelse(adm_2_name %in% NA, 1, 2)))%>%
  mutate(temporal_res = ifelse(diff <8, 2, #weekly
                          ifelse(diff > 7 & diff < 31, 1, #monthly
                                                       0)))%>% #yearly
  #mutate(temporal_res = ifelse(grepl("all_PAHO", data$source_id, ignore.case = FALSE)== TRUE, "2", temporal_res))%>%
  select(adm_0_name:adm_2_code, spatial_res, temporal_res, year, diff,  calendar_start_date:source_cat)

plyr::count(data$diff)
plyr::count(data$spatial_res)
plyr::count(data$temporal_res)

data %>% 
  select(temporal_res, spatial_res, source_cat)%>% 
  group_by(temporal_res, spatial_res, source_cat)%>% tally()

# **** need to check temporal resolution for some of paho subnational data ****
data <- data %>%
  filter(!diff == 83)
  
```
Convert calendar dates back to epi weeks, to help with tallying the number of weeks at each temporal and spatial resolution.
```{r}
# Overwrite EW as month of the calendar_end_date if the temporal resolution is monthly
data <- data %>%
  mutate(EW = lubridate::week(calendar_end_date))%>%
  mutate(EW = ifelse(temporal_res==1, month(calendar_end_date), 
                ifelse(temporal_res==0, NA, EW)))

```


```{r}
plyr::count(data$adm_0_name)

# Make country names consistent
lookup <- c("Antigua And Barbuda" = "Antigua and Barbuda",
         "Dominican republic" = "Dominican Republic",
         "Saint Kitts And Nevis" = "Saint Kitts and Nevis",
         "Saint Vincent And the Grenadines" = "Saint Vincent and the Grenadines",
         "Saint Vincent And The Grenadines" = "Saint Vincent and the Grenadines",
         "Trinidad And Tobago" = "Trinidad and Tobago", 
         "Turks And Caicos Islands" = "Turks and Caicos Islands", 
         "United States Of America" = "United States of America" 
         )


data <- data %>%
  mutate(adm_0_name = recode(adm_0_name, !!!lookup))

plyr::count(data$adm_0_name) #52 countries
```


```{r}
# ordering country by longitude (?)
lookup_order <- read.csv("data/heatmap_order.csv")
names(lookup_order)

#data_ctr <- data %>% select(adm_0_name) %>% distinct()
#data_ctr <- merge(data_ctr, lookup_order, by=c("adm_0_name"), all.x=T, all.y=T)

plyr::count(data$adm_0_name) #alphabetic order 

data$adm_0_name <- factor(data$adm_0_name, 
                          levels = unique(lookup_order$adm_0_name[order(lookup_order$desired_order)]))

plyr::count(data$adm_0_name) #desired order

```

# Summary statistics of data coverage

Produce summary statistics of temporal resolution by each year. temporal resolution is grouped into weekly, monthly, annually.  
The maximum temporal resolution reached for that year is prioritised for colour coding the heatmap. 
The opacity/gradient of the colour is determined by the proportion of the year at which that temporal resolution is available. 

## Temporal resolution
```{r}
# first check if any country-year has data for more than one temporal resolution
data %>%
  mutate(temporal_res_nm = ifelse(temporal_res==2, "Weekly", 
                         ifelse(temporal_res==1, "Monthly", "Yearly")))%>%
  group_by(adm_0_name, year, temporal_res_nm)%>%
  tally()%>%
  mutate(n2 = ifelse(is.na(n)==FALSE, 1, NA))%>% select(-n)%>% 
  spread(., temporal_res_nm, n2)%>%
  mutate(total = Weekly+Monthly+Yearly) %>%
  arrange(desc(total)) #Data for Nicaragua (2004-2005) include different temporal resolutions 

```
No color gradient applied to each cell. It is possible, for example, to only have data for one month of a certain year available.

```{r}
temp_boolean <- data %>%
  group_by(adm_0_name, year, temporal_res)%>%
  tally()%>%
  arrange(adm_0_name, year, desc(temporal_res))%>%  
  group_by(adm_0_name, year) %>% slice_head(n=1)%>% select(-n)%>% ungroup()%>%
  complete(adm_0_name, year) %>%
  mutate(temporal_res_nm = ifelse(temporal_res==2, "Weekly", 
                            ifelse(temporal_res==1, "Monthly", "Yearly")))%>%
  mutate(temporal_res_nm = factor(temporal_res_nm, levels=c("Weekly", "Monthly", "Yearly")))

plyr::count(temp_boolean$adm_0_name)
```

```{r, fig.width = 18, fig.height = 18}
temp_boolean %>%
  filter(!year < 1990)%>%
  mutate(year = as.character(year))%>%
  
ggplot( aes(x=year, y=adm_0_name))+
  geom_tile(aes(fill=temporal_res_nm), 
            color = "white", lwd = 0.25, linetype = 1)+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_discrete(expand=c(0,0),
                   breaks=seq(1990, 2020, by=5)
                     )+
  scale_fill_manual(name = "Temporal resolution", 
                    values = c("#B2DF8A","#1F78B4", "#CAB2D6" ), na.value="#D9D9D9")+
                              #"#6A3D9A", "#FFFF99","#A6CEE3", "#33A02C",   "#B15928"
  coord_fixed()+
  theme_bw()+
  ggtitle("Best temporal resolution available")+
  xlab("Year")+ylab("Country")+
  theme(plot.title = element_text(size=28), 
        axis.title.x = element_text(size=28, vjust=0),
        axis.title.y = element_text(size=28), 
        axis.text = element_text(size=18), 
        axis.ticks = element_line(size=1),
        legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        plot.margin = margin(t=-50, b=-50, l=20, r=20), 
        plot.background = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_blank())
```

## Spatial resolution
```{r}
# first check if any country-year has data for more than one spatial resolution
data %>%
  mutate(spatial_res_nm = ifelse(spatial_res==2, "adm2", 
                         ifelse(spatial_res==1, "adm1", "adm0")))%>%
  group_by(adm_0_name, year, spatial_res_nm)%>%
  tally()%>%
  mutate(n2 = ifelse(is.na(n)==FALSE, 1, NA))%>% select(-n)%>% 
  spread(., spatial_res_nm, n2)%>%
  mutate(total = adm2+adm1+adm0) %>%
  arrange(desc(total)) #Data for Brazil (2001-2005) include different spatial resolutions 

```
No color gradient applied to each cell. It is possible, for example, to only have data for one adm2 area of a certain country available.

```{r}
spat_boolean <- data %>%
  group_by(adm_0_name, year, spatial_res)%>%
  tally()%>%
  arrange(adm_0_name, year, desc(spatial_res))%>%  
  group_by(adm_0_name, year) %>% slice_head(n=1)%>% select(-n)%>% ungroup()%>%
  complete(adm_0_name, year) %>%
  mutate(spatial_res_nm = ifelse(spatial_res==2, "adm2", 
                         ifelse(spatial_res==1, "adm1", "adm0")))%>%
  mutate(spatial_res_nm = factor(spatial_res_nm, levels=c("adm2", "adm1", "adm0")))
```

```{r, fig.width = 18, fig.height = 18}
spat_boolean %>%
  filter(!year < 1990)%>%
  mutate(year = as.character(year))%>%
ggplot( aes(x=year, y=adm_0_name, group=spatial_res_nm))+
  geom_tile(aes(fill=spatial_res_nm), 
            color = "white",  lwd = 0.25, linetype = 1)+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_discrete(  breaks = seq(1990,2020, by=5), 
                     expand=c(0,0))+
  scale_fill_manual(name = "Spatial resolution", 
                    values = c("#B2DF8A","#1F78B4", "#CAB2D6" ), na.value="#D9D9D9")+
  coord_fixed()+
  theme_bw()+
  ggtitle("Best spatial resolution available")+
  xlab("Year")+ylab("Country")+
  theme(plot.title = element_text(size=28), 
        axis.title.x = element_text(size=28, vjust=0),
        axis.title.y = element_text(size=28), 
        axis.text = element_text(size=18), 
        axis.ticks = element_line(size=1),
        legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        plot.margin = margin(t=20, b=20, l=20, r=20), 
        plot.background=element_blank(),
        panel.border=element_blank())
```

## Data source
```{r}
# first check if any country-year has data for more than one data source
data %>%
  group_by(adm_0_name, year, source_cat)%>%
  tally()%>% 
  mutate(n2 = ifelse(is.na(n)==FALSE, 1, NA))%>% select(-n)%>% 
  spread(., source_cat, n2)%>%
  mutate(paho_tot = ifelse(sum(c_across(paho_adm0:paho_imputed), na.rm=T)>0, 1, NA))%>% 
  select(-paho_adm0, -paho_imputed)%>%
  mutate(total = sum(c_across(moh:paho_tot), na.rm = T)) %>%
  arrange(desc(total)) 
```

```{r}
source_boolean <- data %>%
  mutate(source_cat = ifelse(source_cat %in% c("paho_adm0", "paho_imputed"), "paho", source_cat))%>%
  group_by(adm_0_name, year, source_cat)%>%
  tally()%>%
  arrange(adm_0_name, year, desc(n))%>%  
  group_by(adm_0_name, year) %>% slice_head(n=1)%>%  ungroup()%>%
  complete(adm_0_name, year) 

plyr::count(source_boolean$source_cat) # here 'NA' created because of the use of 'complete' function
```
In the case of multiple data sources available for the same country-year, the data source with the most data rows is chosen and shown on the figure below. 
```{r, fig.width = 18, fig.height = 18}
source_boolean %>%
  filter(!year < 1990)%>%
  mutate(year = as.character(year))%>%
ggplot( aes(x=year, y=adm_0_name, group=source_cat))+
  geom_tile(aes(fill=source_cat), 
            color = "white",  lwd = 0.25, linetype = 1)+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_discrete(  breaks = seq(1990,2020, by=5), 
                     expand=c(0,0))+
  scale_fill_manual(name = "Data source", 
                    values = c("#1F78B4","#B2DF8A","#4c841c", "#CAB2D6" ), na.value="#D9D9D9")+
  coord_fixed()+
  theme_bw()+
  ggtitle("Data source available")+
  xlab("Year")+ylab("Country")+
  theme(plot.title = element_text(size=28), 
        axis.title.x = element_text(size=28, vjust=0),
        axis.title.y = element_text(size=28), 
        axis.text = element_text(size=18), 
        axis.ticks = element_line(size=1),
        legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        plot.margin = margin(t=20, b=20, l=20, r=20), 
        plot.background=element_blank(),
        panel.border=element_blank())
```
Temporal/spatial resolution per data source? This is done by comparing the number of country-year data points between different sources. This allows us to identify which data source dominates each temporal resolution.  
```{r}
# first check if any country-year has data for more than one data source
source_temp <- data %>%
  mutate(source_cat = ifelse(source_cat %in% c("paho_adm0", "paho_imputed"), "paho", source_cat))%>%
  group_by(temporal_res, source_cat, adm_0_name, year)%>%
  tally() %>% mutate(n = 1)

source_temp2 <- source_temp %>%
  group_by(temporal_res, source_cat) %>% tally() %>%
  mutate(prop = round(prop.table(n)*100, 1))%>% ungroup()%>%
  complete(temporal_res, source_cat)%>%
  mutate(source_cat_nm = ifelse(source_cat %in% c("moh"), "MoH", 
                      ifelse(source_cat %in% c("paho"), "PAHO", 
                      ifelse(source_cat %in% c("paho_sub"), "PAHO\nsubnational", 
                             "Project\nTycho"))))%>%
  mutate(source_cat_nm = factor(source_cat_nm, levels=c("MoH", "PAHO", "PAHO\nsubnational", "Project\nTycho")))%>%
  mutate(temporal_res_nm = ifelse(temporal_res==2, "Weekly", 
                            ifelse(temporal_res==1, "Monthly", "Yearly")))%>%
  mutate(temporal_res_nm = factor(temporal_res_nm, levels=c("Weekly", "Monthly", "Yearly")))%>%
  mutate(text = ifelse(is.na(n), "0", "1"))%>%
  mutate(labels = ifelse(text %in% c("1"), paste0(sprintf("%.1f", prop), "%") , ""))

```

Summed horizontally. 
```{r}
source_temp2 %>%
  ggplot(aes(x=source_cat_nm, y=temporal_res_nm, fill=prop))+
  geom_tile(color = "white",  lwd = 0.5, linetype = 1)+
  geom_text(aes(x = source_cat_nm, y = temporal_res_nm, label = labels), color = "black", size= 4)+
  scale_fill_distiller(palette = "YlGnBu", direction = 1, na.value="#D9D9D9", name="Proportion (%)")+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_discrete(position = "top", expand=c(0,0))+
  xlab("Data source")+ylab("Temporal resolution")+
  theme(axis.title.x.top = element_text(size=15, face = "bold", margin = margin(b = 0.1, unit = "in")))+
  theme(axis.title.y = element_text(size=15, face = "bold", vjust = 4),
        axis.text.x = element_text(size=12), 
        axis.text.y = element_text(size=12), 
        axis.ticks.x = element_blank(),        
        axis.ticks.y = element_blank(), 
        axis.line=element_blank(),
        panel.background = element_rect(fill = 'white'), 
        panel.grid.major = element_blank(),
        plot.margin = unit(c(1,1,1,1), "cm")
  )+
  theme(legend.title = element_text(size=10),
        legend.text = element_text(size=8, vjust=1),
        legend.margin = margin(9,9,9,9), 
        legend.text.align = 0
  )

# Weekly - PAHO; Monthly - TYCHO; Yearly - TYCHO
```
```{r}
# first check if any country-year has data for more than one data source
source_spat <- data %>%
  mutate(source_cat = ifelse(source_cat %in% c("paho_adm0", "paho_imputed"), "paho", source_cat))%>%
  group_by(spatial_res, source_cat, adm_0_name, year)%>%
  tally() %>% mutate(n = 1)

source_spat2 <- source_spat %>%
  group_by(spatial_res, source_cat) %>% tally() %>%
  mutate(prop = round(prop.table(n)*100, 1))%>% ungroup()%>%
  complete(spatial_res, source_cat)%>%
  mutate(source_cat_nm = ifelse(source_cat %in% c("moh"), "MoH", 
                      ifelse(source_cat %in% c("paho"), "PAHO", 
                      ifelse(source_cat %in% c("paho_sub"), "PAHO\nsubnational", 
                             "Project\nTycho"))))%>%
  mutate(source_cat_nm = factor(source_cat_nm, levels=c("MoH", "PAHO", "PAHO\nsubnational", "Project\nTycho")))%>%
  mutate(spatial_res_nm = ifelse(spatial_res==2, "Admin 2", 
                            ifelse(spatial_res==1, "Admin 1", "Admin 0")))%>%
  mutate(spatial_res_nm = factor(spatial_res_nm, levels=c("Admin 2", "Admin 1", "Admin 0")))%>%
  mutate(text = ifelse(is.na(n), "0", "1"))%>%
  mutate(labels = ifelse(text %in% c("1"), paste0(sprintf("%.1f", prop), "%") , ""))

```

```{r}
source_spat2 %>%
  ggplot(aes(x=source_cat_nm, y=spatial_res_nm, fill=prop))+
  geom_tile(color = "white",  lwd = 0.5, linetype = 1)+
  geom_text(aes(x = source_cat_nm, y = spatial_res_nm, label = labels), color = "black", size= 4)+
  scale_fill_distiller(palette = "OrRd", direction = 1, na.value="#D9D9D9", name="Proportion (%)")+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_discrete(position = "top", expand=c(0,0))+
  xlab("Data source")+ylab("Spatial resolution")+
  theme(axis.title.x.top = element_text(size=15, face = "bold", margin = margin(b = 0.1, unit = "in")))+
  theme(axis.title.y = element_text(size=15, face = "bold", vjust = 4),
        axis.text.x = element_text(size=12), 
        axis.text.y = element_text(size=12), 
        axis.ticks.x = element_blank(),        
        axis.ticks.y = element_blank(), 
        axis.line=element_blank(),
        panel.background = element_rect(fill = 'white'), 
        panel.grid.major = element_blank(),
        plot.margin = unit(c(1,1,1,1), "cm")
  )+
  theme(legend.title = element_text(size=10),
        legend.text = element_text(size=8, vjust=1),
        legend.margin = margin(9,9,9,9), 
        legend.text.align = 0
  )

# Adm2 - MoH; Adm1 - equally distributed; Adm0 - Tycho. adm2 and adm1 code matching needs to be done to ensure more accurate data coverage though...
```


```{r, include= FALSE}
#select the best temporal resolution when spatial resolution == adm0 
names(data)
data_temporal_adm0 <- data %>%
  group_by(adm_0_name, year, temporal_res, spatial_res)%>%
  tally()%>%
  filter(spatial_res == 0)%>%
  arrange(adm_0_name, year, desc(temporal_res))%>%  
  group_by(adm_0_name, year) %>% slice_head(n=1)

# denominator for weekly = 53, for monthly = 12
data_temporal_adm0 <- data_temporal_adm0 %>%
  mutate(n2 = ifelse(n > 53, 53, n))%>% 
  mutate(prop = ifelse(temporal_res==1, n2/12, 
                       ifelse(temporal_res==0, n2/1, n2/53)))%>%
  mutate(temporal_res_nm = ifelse(temporal_res ==2, "Weekly", 
                               ifelse(temporal_res==1, "Monthly", "Yearly")))
```


```{r, include= FALSE}
# 'n' refers to the number of data rows per country, year, time units (EW). For example, when a data row contains [Argentina - 2015 - weekly data - EW 15 - adm2 ] and n = 20, it means they are data for the week 15 of 2015 and for 20 different adm2 areas in Argentina. We do this to determine whether the abundance of data for each country is due to true high data coverage or a false impression caused by a large number of spatial units.
nb_spatial_unit <- data %>% 
  group_by(adm_0_name, year, temporal_res, EW, spatial_res)%>%
  tally() 

# number of spatial units reported vary depending on the country and year. We calculated the maximum number of spatial units reported country and to use it as a denominator.  
nb_spatial_unit_adm1 <- nb_spatial_unit %>%
  filter(!is.na(EW))%>%
  group_by(adm_0_name, temporal_res, spatial_res)%>%
  summarise(nb_sp_units = max(n))%>%
  filter(spatial_res==1)

nb_spatial_unit_adm2 <- nb_spatial_unit %>%
  filter(!is.na(EW))%>%
  group_by(adm_0_name, temporal_res, spatial_res)%>%
  summarise(nb_sp_units = max(n))%>%
  filter(spatial_res==2)
```


```{r, include= FALSE}
# ** work on progress 
#select the best temporal resolution when spatial resolution == adm1
data_temporal_adm1 <- data %>%
  group_by(adm_0_name, year, temporal_res, spatial_res, EW)%>%
  tally()%>%
  filter(spatial_res == 1)%>%
  arrange(adm_0_name, year, desc(temporal_res))%>%  
  group_by(adm_0_name, year) %>% slice_head(n=1)

# denominator for weekly = 53, for monthly = 12
data_temporal_adm1 <- data_temporal_adm1 %>%
  mutate(n2 = ifelse(n > 53, 53, n))%>% 
  mutate(prop = ifelse(temporal_res==1, n2/12, 
                       ifelse(temporal_res==0, n2/1, n2/53)))%>%
  mutate(temporal_res_nm = ifelse(temporal_res ==2, "Weekly", 
                               ifelse(temporal_res==1, "Monthly", "Yearly")))
```



```{r, include= FALSE}
#Produce summary statistics of spatial resolution by each year. Spatial resolution is grouped into admin 0, 1 & 2.. 
#The maximum spatial resolution reached for that year is prioritised for colour coding the heatmap.
#The gradient of colour that applies to temporal resolution does not yet apply to spatial resolution. This is because while we plan to gradient it according to the proportion of the country that is available at that that resolution, we do not yet have all of the admin2 code kmatching complete in order to do so. 

data_spatial <- data %>% 
  #filter(spatial_res %in% c('A0'))%>%
  group_by(year, spatial_res)%>%
  tally()%>%
  #===number of temporal resolutions available
  #group_by(year) %>% 
  #mutate(n2 = n())%>% 
  #select the best temporal resolution 
  arrange(year, desc(spatial_res))%>%   print (n=30)%>%
  group_by(year) %>% slice_head(n=1)%>%
  #tidyr::spread(., temporal_res, n) 
  #mutate(yearly = ifelse(is.na(monthly)==FALSE & is.na(yearly)==FALSE, NA, yearly))%>%
  #tidyr::gather(., temporal_res, n, monthly:yearly) %>% print(n=72) %>% 
  filter(!n %in% NA)

  
```


```{r, fig.width = 18, fig.height = 18, include = FALSE}
# Visualisations

#Produce heatmaps for country by temporal resolution and then spatial resoluton. note that this will only be a single row for this country on it's own, though when all country datasets are processed a fuller map will be developed.

# Data coverage by temporal resolution 

ggplot(data_temporal_adm0, aes(x=year, y=adm_0_name, group=temporal_res_nm))+
  geom_tile(aes(alpha = prop, fill=temporal_res_nm), 
            color = "white",  lwd = 0.25, linetype = 1)+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_continuous(limits = c(1988, 2022), 
                     breaks = seq(1990,2020, by=5), 
                     expand=c(0,0))+
  scale_fill_manual(name = "Temporal resolution", 
                    values = c("#1F78B4","#B2DF8A","#FB9A99"))+
  scale_alpha(guide = 'none')+
  coord_fixed()+
  theme_grey()+
  ggtitle("Best temporal resolution available for adm0")+
  xlab("Year")+ylab("Country")+
  theme(plot.title = element_text(size=28), 
        axis.title = element_text(size=28), 
        axis.text = element_text(size=18), 
        axis.ticks = element_line(size=1),
        legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        plot.margin = margin(t=-50, b=-50, l=20, r=20), 
        plot.background=element_blank(),
        panel.border=element_blank())

```

```{r, fig.width = 18, fig.height = 18, include = FALSE}
## Data coverage by spatial resolution 

data %>%
  filter(!spatial_res==2)%>%
  group_by(adm_0_name, year)%>%
  tally()%>%
  ggplot(aes(x=year, y=adm_0_name))+
  geom_tile(aes(fill=n), lwd = 0.25, linetype = 1)+
  scale_y_discrete(limits=rev, expand=c(0,0))+
  scale_x_continuous(limits = c(1988, 2022), 
                     breaks = seq(1990,2020, by=5), 
                     expand=c(0,0))+
  scale_fill_distiller(palette = "YlGnBu", direction = 1, na.value="#D9D9D9", name="Row count")+
  coord_fixed()+
  theme_grey()+
  xlab("Year")+ylab("Country")+
  theme(plot.title = element_text(size=28), 
        axis.title = element_text(size=28), 
        axis.text = element_text(size=18), 
        axis.ticks = element_line(size=1),
        legend.title = element_text(size=20),
        legend.text = element_text(size=18), 
        plot.margin = margin(t=-50, b=-50, l=20, r=20), 
        plot.background=element_blank(),
        panel.border=element_blank())
```


